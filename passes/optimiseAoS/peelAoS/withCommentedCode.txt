#include "llvm/Pass.h"
#include "llvm/Passes/PassBuilder.h"
#include "llvm/Passes/PassPlugin.h"
#include "llvm/Support/raw_ostream.h"

#include "llvm/Analysis/LoopInfo.h"

using namespace llvm;
using namespace std;

LLVMContext TheContext;
IRBuilder<> Builder(TheContext);

// void runOnLoop(Loop* L) {
//   int Count = 0;
//   //following for loop does not work
//   // for (auto Iter = L->block_begin(), End = L->block_end(); Iter != End; ++Iter) {
//   //   // Count += Iter->size();
//   //   errs()<<"yes\n";
//   // }
//   // Do something with Count
//   // return false;
// }

//iterate through all structs
          //iterate through all globals
            //find globals that use the curr struct and add to list
          //if list > 0, apply struct peeling (use existing code)
            //create new cold struct
            //calculate new indices
          //else continue to next struct

          //for each global in list
            //create new cold global
            //iterate through all GEP
              //if GEP accesses a global (first operand) and source == curr struct and return == curr struct
                //set pred to true
              //if pred is true and source == curr struct and return != curr struct
                //determine whether a cold or hot index was used and make aprropriate changes (use existing code)


namespace {

//For Function Pass, use run(Function &F, FunctionAnalysisManager &FM)
struct peelAoS : public PassInfoMixin<peelAoS> {
    PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM) {
        
        //Since there is no way to get names of each struct element, each element will be uniquely identified by its type and index

        //iterate through all global variables

        //use following code to find struct used by the global

        //change GEP indices and ptr

        vector<StructType*> allStructs = M.getIdentifiedStructTypes(); //get all struct types used in program

        for(int i = 0; i < allStructs.size(); i++)
        {
          StructType* currStruct = allStructs.at(i);

          vector<llvm::Module::global_iterator> globalAoS; //stores all global variables that work on the current struct

          for(auto Global = M.global_begin(); Global != M.global_end(); ++Global)
          {
            // Global->print(errs());
            // errs()<<"\n";
            Constant* constValue; //initalizer
            constValue = Global->getInitializer();
            // constValue->print(errs());
            // errs()<<"\n";
            Type* t = constValue->getType();
            string type_str;
            raw_string_ostream tstr(type_str);
            t->print(tstr);


            // globalAlign = Global->getAlign();
            // globalName = Global->getName().str();
            // errs()<<"a: "<<globalName<<"\n";
            // globalName = globalName.append("Cold");
            // errs()<<"b: "<<globalName<<"\n";


            // cv->getType()->print(errs());

            // if(auto *CA = dyn_cast<ConstantA>(cv))
            // {
            //   errs()<<"sdads\n";
            // }

            Type* globalElem;
            // int globalSize;

            if(auto *AT = dyn_cast<ArrayType>(t))
            {
              errs()<<"global is an AoS\n";
              // ArrayType* AT = CA->getType();
              globalElem = AT->getArrayElementType();
              // globalSize = AT->getNumElements();
              // globalElem->printAsO(errs());
              // errs()<<"dd\n";
            }

            if(t->isAggregateType() & (type_str.find("%struct") != string::npos) & (currStruct == globalElem))
            {
              errs()<<"proceed\n";
              globalAoS.push_back(Global);
            }
            else
              continue;

            // isDSOLocal = Global->isDSOLocal();
            // linkageType = Global->getLinkage();
          }

          if(globalAoS.size() > 0) //proceed with peeling if global AoS exists using current struct, else continue
          {
             vector<int> elems;

            for(int j = 0; j < currStruct->elements().size(); j++)
              elems.push_back(0);

            for (auto &F : M) 
            { 
              for (auto &B : F)  
              {
                // LoopInfo& loops = getAnalysis<LoopInfoWrapperPass>().getLoopInfo(); //sort this out ltr - check trello

                //// SORT OUT LATER ////
                // LoopInfo LI = LoopInfo();
                // Loop* l = LI.getLoopFor(&B); 
                // runOnLoop(l); //gives seg fault


                for (auto &I : B) /// iterate through all instructions
                {
                  if(auto *GEP = dyn_cast<GetElementPtrInst>(&I))
                  {
                    // string src_string;
                    // raw_string_ostream str(src_string);
                    // GEP->getSourceElementType()->print(str);

                    // errs()<<src_string<<"\n";

                    if(GEP->getSourceElementType() == currStruct & GEP->getResultElementType() != currStruct)
                    {
                      string operand_str;
                      raw_string_ostream str(operand_str);
                      Value* index = GEP->getOperand(GEP->getNumIndices()); //get last index value being access
                      index->printAsOperand(str);

                      size_t space_pos = operand_str.find(" ");    
                      string type;
                      string indexStr;

                      //string manipulation to get 'type' and 'name' of the indices
                      if (space_pos != std::string::npos) 
                      {
                        type = operand_str.substr(0, space_pos);
                      }

                      indexStr = operand_str.substr(space_pos + 1);

                      int in = std::stoi(indexStr);

                      errs()<<in<<"\n";

                      //increment index counter
                      int count = elems.at(in);
                      count++;
                      elems.at(in) = count;
                    }
                  }
                }
            }
          }

          int total = 0;
          int mean = 0;
          for(int j = 0; j < elems.size(); j++)
          {
            errs()<<"Index "<<j<<", Count "<<elems.at(j)<<" \n";
            //find mean count
            total += elems.at(j);
          }
          mean = total/elems.size();

          errs()<<"Mean no. of accesses: "<<mean<<"\n";

              // split fields based on mean no. of accesses
          // with no. of accesses > mean, put field in hot struct
          // with no. of accesses < mean, put field in cold struct

          ArrayRef<Type*> elemTypes = currStruct->elements();
          
          vector<Type*> hotFields;
          vector<pair<int,int>> hotIndices;
          vector<Type*> coldFields;
          vector<pair<int,int>> coldIndices;

          int index = 0;
          int coldIndex = 0;
          int hotIndex = 0;
          for(auto it = elemTypes.begin(); it != elemTypes.end(); it++)
          {
            if(elems.at(index) > mean)
            {
              // errs()<<elems.at(index)<<"\n";
              hotFields.push_back(*it);
              hotIndices.push_back(make_pair(index,hotIndex));
              hotIndex++;
            }
            else if(elems.at(index) <= mean)
            {
              // errs()<<index<<"c:"<<elems.at(index)<<"\n";
              coldFields.push_back(*it);
              coldIndices.push_back(make_pair(index,coldIndex));
              coldIndex++;
            }

            index++;
          }

          ArrayRef<Type*> newHotFields = ArrayRef(hotFields);
          ArrayRef<Type*> newColdFields = ArrayRef(coldFields);

          // StructType* hotStruct = StructType::create(TheContext, allStructs.at(i)->getName().str()); //cold struct
          // hotStruct->setBody(newHotFields); //hot struct

          // hotStruct->print(errs());
          // errs()<<"\n";
          
          allStructs.at(i)->setBody(newHotFields); //hot struct
          
          string coldName = currStruct->getName().str();
          coldName = coldName.append("Cold");

          StructType* coldStruct = StructType::create(TheContext, coldName); //cold struct
          coldStruct->setBody(coldFields);

          // coldStruct->print(errs());
          // errs()<<"\n";

          // //create new global cold array, same size as original
          // errs()<<"setting new array: "<<globalName<<"\n";
          // Type* newTy = ArrayType::get(coldStruct,globalSize);
          // coldArray = new GlobalVariable(M, newTy, false, linkageType, Constant::getNullValue(newTy));
          // coldArray->setName(globalName); //set name
          // coldArray->setAlignment(globalAlign); //set alignment
          // coldArray->setDSOLocal(isDSOLocal);

              //now iterate through all GEP instructions
          //if cold field is used, replace first operand of GEP inst with new struct
            // also change index 
          //if hot field is used, replace with correct index

          for(int j = 0; j < globalAoS.size(); j++)
          {
            llvm::Module::global_iterator curr = globalAoS.at(j); //current global AoS

            string global_str; //store global AoS name as a string
            raw_string_ostream str(global_str);
            curr->print(str);

            errs()<<"processing "<<global_str<<"\n";

            bool isDSOLocal = curr->isDSOLocal();
            GlobalValue::LinkageTypes linkageType = curr->getLinkage();

            Type* globalElem;
            int globalSize;
            MaybeAlign globalAlign;
            string globalName;

            Constant* constValue; //initalizer
            constValue = curr->getInitializer();    
            Type* t = constValue->getType();

            globalAlign = curr->getAlign();
            globalName = curr->getName().str();
            errs()<<"a: "<<globalName<<"\n";
            globalName = globalName.append("Cold");
            errs()<<"b: "<<globalName<<"\n";

            if(auto *AT = dyn_cast<ArrayType>(t))
            {
              errs()<<"global is an AoS\n";

              globalElem = AT->getArrayElementType();
              globalSize = AT->getArrayNumElements();
            }

            errs()<<"SIZE: "<<globalSize<<"\n";

            errs()<<"setting new array: "<<globalName<<"\n";
            Type* newTy = ArrayType::get(coldStruct,globalSize);
            GlobalVariable* coldArray = new GlobalVariable(M, newTy, false, linkageType, Constant::getNullValue(newTy));
            coldArray->setName(globalName); //set name
            coldArray->setAlignment(globalAlign); //set alignment
            coldArray->setDSOLocal(isDSOLocal);

              GetElementPtrInst* pred; //stores preceding GEP inst
              Type* elemType;
              int numElem;
              bool predSet = false;
              for(auto &F : M) 
              { 
                for(auto &B : F)  
                {
                  // LoopInfo LI = LoopInfo();
                  // Loop* l = LI.getLoopFor(&B); 
                  // runOnLoop(l); //gives seg fault
                  for(auto &I : B) /// iterate through all instructions
                  {
                    if(auto *GEP = dyn_cast<GetElementPtrInst>(&I))
                    {
                      
                      Type* op = GEP->getSourceElementType();
                      string op_string;
                      raw_string_ostream ostr(op_string);
                      op->print(ostr);

                      string ptr_string;
                      raw_string_ostream pstr(ptr_string);
                      GEP->getOperand(0)->print(pstr);



                      // GEP->getOperand(0)->print(errs());
                      // errs()<<"\n";

                      // errs()<<op_string<<"--\n";
                      // allStructs.at(i)->print(errs());
                      // errs()<<"\n";
                                        
                      // errs()<<"orig global name: "<<global_str<<"\n";
                      // errs()<<"ptr global name: "<<ptr_string<<"\n";


                      if(ptr_string == global_str)
                        errs()<<"match\n";


                      if(auto *AT = dyn_cast<ArrayType>(op))
                      {
                        elemType = AT->getArrayElementType();
                        numElem = AT->getNumElements();
                        // errs()<<"no: "<<numElem<<"\n";
                      }
                      // else
                      // {
                      //   continue;
                      // }

                      // space_pos = op_string.find(" ");    
                      // string opName;

                      // //string manipulation to get name of struct
                      // if (space_pos != std::string::npos) 
                      //   opName = src_string.substr(0, space_pos);   

                      //check if this is an aggregate type containing the struct e.g. [99 x %struct.nodeOneOld]

                      //ONLY CHANGE GEP 

                      // if(GEP->getSourceElementType() == allStructs.at(i) & GEP->getResultElementType() == allStructs.at(i) & predSet == false)
                      if(op->isAggregateType() & (elemType == currStruct) & predSet == false & (global_str == ptr_string))
                      {
                        pred = GEP;
                        predSet = true;
                        // errs()<<"pred set\n";
                      } 
                      else if(GEP->getSourceElementType() == currStruct & GEP->getResultElementType() != currStruct & predSet == true) //is second condition needed?
                      {
                        //getting index used in GEP
                        // errs()<<"changing index\n";
                        string operand_str;
                        raw_string_ostream opstr(operand_str);
                        Value* index = GEP->getOperand(GEP->getNumIndices()); //get last index value being access
                        index->printAsOperand(opstr);

                        size_t space_pos = operand_str.find(" ");    
                        string type;
                        string indexStr;

                        //string manipulation to get 'type' and 'name' of the indices
                        if (space_pos != std::string::npos) 
                        {
                          type = operand_str.substr(0, space_pos);
                        }

                        indexStr = operand_str.substr(space_pos + 1);

                        int in = std::stoi(indexStr);

                        bool isColdIndex = false;
                        bool isHotIndex = false;
                        int newIndex = 0;

                        while(isColdIndex == false & isHotIndex == false)
                        {
                          for(int j = 0; j < coldIndices.size(); j++)
                          {
                            // errs()<<coldIndices.at(j).first<<"\n";
                            if(coldIndices.at(j).first == in)
                            {
                              errs()<<"found cold\n";
                              isColdIndex = true;
                              newIndex = coldIndices.at(j).second;
                              break;
                            }
                          }

                          for(int j = 0; j < hotIndices.size(); j++)
                          {
                            // errs()<<hotIndices.at(j).first<<"\n";
                            if(hotIndices.at(j).first == in)
                            {
                              errs()<<"found hot\n";
                              isHotIndex = true;
                              newIndex = hotIndices.at(j).second;
                              break;
                            }
                          }
                        }

                        if(isHotIndex & !isColdIndex)
                        {
                          errs()<<"hot index\n";
                          Type* newTy = ArrayType::get(currStruct,numElem);
                          pred->setSourceElementType(newTy);
                          pred->setResultElementType(currStruct);
                          GEP->setOperand(GEP->getNumIndices(),ConstantInt::get(TheContext,APInt(32,newIndex)));
                          GEP->setSourceElementType(currStruct);
                        }
                        else if(!isHotIndex & isColdIndex)
                        {
                          errs()<<"cold index\n";
                          Type* newTy = ArrayType::get(coldStruct,numElem); //not correctly set
                          pred->setSourceElementType(newTy);
                          pred->setResultElementType(coldStruct);
                          GEP->setOperand(GEP->getNumIndices(),ConstantInt::get(TheContext,APInt(32,newIndex)));
                          GEP->setSourceElementType(coldStruct);
                          pred->setOperand(0,coldArray);
                        }
                        predSet = false;
                      }

                      //change ptr of GEP to hot or cold array

                    }
                }
              }
            }
          }


          }//end of code
        }

        //Set to ::all() if IR is unchanged, otherwise ::none()
        return PreservedAnalyses::none();
    };
};

}


//Creates plugin for pass - required
extern "C" ::llvm::PassPluginLibraryInfo LLVM_ATTRIBUTE_WEAK
llvmGetPassPluginInfo() {
  return {
    LLVM_PLUGIN_API_VERSION, "passName", "v0.1",
    [](PassBuilder &PB) {
      PB.registerPipelineParsingCallback(
        [](StringRef Name, ModulePassManager &MPM, //For FunctionPass use FunctionPassManager &FPM
        ArrayRef<PassBuilder::PipelineElement>) {
          if(Name == "peelAoS"){ //name of pass
            MPM.addPass(peelAoS());
            return true;
          }
          return false;
        }
      );
    }
  };
}
